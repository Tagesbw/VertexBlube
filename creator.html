<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–†–µ–¥–∞–∫—Ç–æ—Ä —É—Ä–æ–≤–Ω–µ–π —Å —Ä–µ–∂–∏–º–æ–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Segoe UI', sans-serif;
    }
    #toolbar {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      background: #333;
      padding: 5px 10px;
      gap: 10px;
    }
    .tool-btn {
      width: 32px;
      height: 32px;
      background: #222;
      border: 2px solid #666;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
    }
    .tool-btn.active {
      border-color: yellow;
    }
    .main-btn {
      padding: 6px 14px;
      background: #222;
      color: white;
      border: 1px solid #666;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: background 0.2s ease;
    }
    .main-btn:hover {
      background: #444;
    }
    canvas {
      display: block;
      width: 100%;
      height: calc(100% - 45px);
      background: black;
    }
  </style>
</head>
<body>

<!-- –ü–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤: –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã -->
<div id="toolbar">
  <button class="main-btn" id="btn-play">‚ñ∂ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å</button>
  <button class="main-btn" id="btn-stop" style="display: none;">‚ñ† –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
  
  <div class="tool-btn" data-type="wall" title="–°—Ç–µ–Ω–∞" style="background:#555;"></div>
  <div class="tool-btn" data-type="ban" title="–ó–∞–ø—Ä–µ—â–µ–Ω–æ" style="background:red;"></div>
  <div class="tool-btn" data-type="spawn" title="–ü–æ—è–≤–ª–µ–Ω–∏–µ" style="background:white; color:black;">‚óà</div>
  <div class="tool-btn" data-type="finish" title="–§–∏–Ω–∏—à" style="background:lime; color:black;">‚úî</div>
  
  <!-- –ù–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ -->
  <div class="tool-btn" data-type="shrink" title="–£–º–µ–Ω—å—à–∞—é—â–∏–µ" style="background:purple;">S</div>
  <div class="tool-btn" data-type="grow" title="–£–≤–µ–ª–∏—á–∏–≤–∞—é—â–∏–µ" style="background:orange;">G</div>
  
  <button class="main-btn" id="btn-save">üíæ –°–∫–∞—á–∞—Ç—å</button>
</div>

<canvas id="editorCanvas"></canvas>

<script>
  const canvas = document.getElementById('editorCanvas');
  const ctx = canvas.getContext('2d');
  const gridSize = 40; // –†–∞–∑–º–µ—Ä –∫–ª–µ—Ç–∫–∏

  const btnPlay = document.getElementById('btn-play');
  const btnStop = document.getElementById('btn-stop');

  const player = {
    x: 75,
    y: 75,
    size: 45,
    vx: 0,
    vy: 0,
    gravityX: 0,
    gravityY: 0.2,
    color: 'deepskyblue'
  };

  let isPlayMode = false;
  let gameEnded = false;  // –§–ª–∞–≥ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä—ã
  let endMessage = "";    // –ò—Ç–æ–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
  let blocks = [];
  let spawnPoint = null;
  let finishPoint = null;
  let currentMouseX = 0, currentMouseY = 0;
  let isDragging = false; // –†–∏—Å–æ–≤–∞–Ω–∏–µ –±–ª–æ–∫–∞ –ª–µ–≤–æ–π –∫–Ω–æ–ø–∫–æ–π
  let startX = 0, startY = 0;
  let selectedType = 'wall';

  // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –ø—Ä–∞–≤–æ–π –∫–Ω–æ–ø–∫–æ–π (—É–¥–∞–ª–µ–Ω–∏–µ –±–ª–æ–∫–æ–≤)
  let isRightDragging = false;
  let startRightX = 0, startRightY = 0;
  let currentRightX = 0, currentRightY = 0;

  // –§—É–Ω–∫—Ü–∏—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Ä–µ–∂–∏–º–∞
  function stopTestMode() {
    isPlayMode = false;
    btnStop.style.display = 'none';
    btnPlay.style.display = 'inline-block';
    player.vx = 0;
    player.vy = 0;
    player.gravityX = 0;
    player.gravityY = 0.2;
    if (spawnPoint) {
      player.x = spawnPoint.x + gridSize / 2 - player.size / 2;
      player.y = spawnPoint.y + gridSize / 2 - player.size / 2;
    }
    gameEnded = false;
    endMessage = "";
  }

  // –§—É–Ω–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä—ã (–±–µ–∑ –≤—Å–ø–ª—ã–≤–∞—é—â–∏—Ö –æ–∫–æ–Ω)
  function endGame(status) {
    if (gameEnded) return;
    gameEnded = true;
    stopTestMode();
    if (status === 'win') {
      endMessage = "–ü–æ–±–µ–¥–∞!";
    } else if (status === 'lose') {
      endMessage = "–ü–æ—Ä–∞–∂–µ–Ω–∏–µ!";
    }
  }

  // –ü–æ–¥–≥–æ–Ω–∫–∞ —Ä–∞–∑–º–µ—Ä–æ–≤ –∫–∞–Ω–≤–∞—Å–∞
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–≤–µ–∑–¥–Ω–æ–≥–æ –Ω–µ–±–∞
  const stars = Array.from({ length: 300 }).map(() => ({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    radius: Math.random() * 1.5 + 0.5,
    alpha: Math.random() * 0.5 + 0.5,
    dx: (Math.random() - 0.5) * 0.2,
    dy: (Math.random() - 0.5) * 0.2
  }));

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–æ–≤ –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º
  document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      selectedType = btn.dataset.type;
    });
  });

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π –º—ã—à–∏ –Ω–∞ –∫–∞–Ω–≤–∞—Å–µ
  canvas.addEventListener('mousedown', (e) => {
    if (isPlayMode) return;
    const x = Math.floor(e.offsetX / gridSize) * gridSize;
    const y = Math.floor(e.offsetY / gridSize) * gridSize;

    // –õ–µ–≤—ã–π –∫–ª–∏–∫ ‚Äì —Å–æ–∑–¥–∞–Ω–∏–µ –±–ª–æ–∫–∞ –∏–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ spawn/finish
    if (e.button === 0) {
      if (selectedType === 'spawn') {
        spawnPoint = { x, y, w: gridSize, h: gridSize };
        return;
      }
      if (selectedType === 'finish') {
        finishPoint = { x, y, w: gridSize, h: gridSize };
        return;
      }
      startX = x;
      startY = y;
      isDragging = true;
    }
    // –ü—Ä–∞–≤—ã–π –∫–ª–∏–∫ ‚Äì –Ω–∞—á–∞–ª–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –±–ª–æ–∫–æ–≤
    else if (e.button === 2) {
      e.preventDefault();
      startRightX = x;
      startRightY = y;
      isRightDragging = true;
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    currentMouseX = e.offsetX;
    currentMouseY = e.offsetY;
    if (isRightDragging) {
      currentRightX = Math.floor(e.offsetX / gridSize) * gridSize;
      currentRightY = Math.floor(e.offsetY / gridSize) * gridSize;
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    // –õ–µ–≤—ã–π –∫–ª–∏–∫ –∑–∞–≤–µ—Ä—à–∞–µ—Ç —Ä–∏—Å–æ–≤–∞–Ω–∏–µ –±–ª–æ–∫–∞
    if (e.button === 0 && isDragging && !isPlayMode && selectedType !== 'spawn' && selectedType !== 'finish') {
      isDragging = false;
      const endX = Math.ceil(e.offsetX / gridSize) * gridSize;
      const endY = Math.ceil(e.offsetY / gridSize) * gridSize;
      const x = Math.min(startX, endX);
      const y = Math.min(startY, endY);
      const w = Math.abs(endX - startX);
      const h = Math.abs(endY - startY);
      if (w > 0 && h > 0) {
        blocks.push({ x, y, w, h, type: selectedType });
      }
    }
    // –ü—Ä–∞–≤—ã–π –∫–ª–∏–∫ –∑–∞–≤–µ—Ä—à–∞–µ—Ç –≤—ã–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –±–ª–æ–∫–æ–≤
    else if (e.button === 2 && isRightDragging && !isPlayMode) {
      isRightDragging = false;
      const endX = Math.ceil(e.offsetX / gridSize) * gridSize;
      const endY = Math.ceil(e.offsetY / gridSize) * gridSize;
      const selX = Math.min(startRightX, endX);
      const selY = Math.min(startRightY, endY);
      const selW = Math.abs(endX - startRightX);
      const selH = Math.abs(endY - startRightY);
      blocks = blocks.filter(b => {
        const intersect = selX < b.x + b.w &&
                          selX + selW > b.x &&
                          selY < b.y + b.h &&
                          selY + selH > b.y;
        return !intersect;
      });
    }
  });

  // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é –Ω–∞ –ü–ö–ú
  canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
  });

  // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–µ–π –∏–≥—Ä–æ–∫–∞ –∫–ª–∞–≤–∏—à–∞–º–∏
  window.addEventListener('keydown', e => {
    if (!isPlayMode) return;
    switch (e.key) {
      case 'ArrowUp':    player.gravityX = 0;    player.gravityY = -0.2;   break;
      case 'ArrowDown':  player.gravityX = 0;    player.gravityY =  0.2;   break;
      case 'ArrowLeft':  player.gravityX = -0.2; player.gravityY =  0;     break;
      case 'ArrowRight': player.gravityX =  0.2; player.gravityY =  0;     break;
    }
  });

  // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ —á–∞—Å—Ç–∏—Ü –¥–ª—è –∑–æ–Ω shrink/grow
  // –ß–∞—Å—Ç–∏—Ü—ã –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å—Ç—Ä–µ–ª–æ—á–∫–∏ —Å —Ä–∞–∑–º–µ—Ä–∞–º–∏ –æ—Ç 15 –¥–æ 25 –ø–∏–∫—Å–µ–ª–µ–π, –≤—ã–±–∏—Ä–∞—é—â–∏–µ —Å–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç –∏ —Å–∏–º–≤–æ–ª
  function updateAndDrawParticles(block) {
    if (!block.particles) {
      block.particles = [];
      const numParticles = 50; // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ —á–∞—Å—Ç–∏—Ü
      for (let i = 0; i < numParticles; i++) {
        let p = {
          x: Math.random() * block.w,
          y: Math.random() * block.h,
          vx: (Math.random() - 0.5) * 1.0,
          vy: (Math.random() - 0.5) * 1.0,
          size: Math.random() * 10 + 15, // –æ—Ç 15 –¥–æ 25 –ø–∏–∫—Å–µ–ª–µ–π
          life: Math.random() * 200 + 100
        };
        p.maxLife = p.life;
        if (block.type === "shrink") {
          const purpleSet = ["#BA55D3", "#9400D3", "#8A2BE2", "#9932CC"];
          p.color = purpleSet[Math.floor(Math.random() * purpleSet.length)];
          p.arrow = "‚Üì";
        } else if (block.type === "grow") {
          const orangeSet = ["#FFA500", "#FF8C00", "#FFD700", "#FFB347"];
          p.color = orangeSet[Math.floor(Math.random() * orangeSet.length)];
          p.arrow = "‚Üë";
        }
        block.particles.push(p);
      }
    }
    for (const p of block.particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.life--;
      if (p.life <= 0) {
        p.x = Math.random() * block.w;
        p.y = Math.random() * block.h;
        p.vx = (Math.random() - 0.5) * 1.0;
        p.vy = (Math.random() - 0.5) * 1.0;
        p.size = Math.random() * 10 + 15;
        p.life = Math.random() * 200 + 100;
        p.maxLife = p.life;
        if (block.type === "shrink") {
          const purpleSet = ["#BA55D3", "#9400D3", "#8A2BE2", "#9932CC"];
          p.color = purpleSet[Math.floor(Math.random() * purpleSet.length)];
          p.arrow = "‚Üì";
        } else if (block.type === "grow") {
          const orangeSet = ["#FFA500", "#FF8C00", "#FFD700", "#FFB347"];
          p.color = orangeSet[Math.floor(Math.random() * orangeSet.length)];
          p.arrow = "‚Üë";
        }
      }
      if (p.x < 0) p.x = block.w;
      if (p.x > block.w) p.x = 0;
      if (p.y < 0) p.y = block.h;
      if (p.y > block.h) p.y = 0;
      // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å alpha, –µ—Å–ª–∏ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è, –Ω–æ –¥–ª—è —è—Ä–∫–æ—Å—Ç–∏ —Ü–≤–µ—Ç–∞ –æ—Å—Ç–∞–≤–ª—è–µ–º –µ–≥–æ –∫–∞–∫ –µ—Å—Ç—å
      ctx.beginPath();
      ctx.font = p.size + "px Segoe UI";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = p.color;
      ctx.fillText(p.arrow, block.x + p.x, block.y + p.y);
    }
  }

  // –§—É–Ω–∫—Ü–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –∫–æ–ª–ª–∏–∑–∏–π –∏–≥—Ä–æ–∫–∞ —Å –±–ª–æ–∫–∞–º–∏ —Ç–∏–ø–∞ "wall"
  function resolvePlayerCollisions() {
    let iterations = 0;
    const maxIterations = 10;
    while (iterations < maxIterations) {
      let collisionFound = false;
      let mtv = { x: 0, y: 0, overlap: Infinity };
      for (const b of blocks) {
        if (b.type !== 'wall') continue;
        if (player.x < b.x + b.w &&
            player.x + player.size > b.x &&
            player.y < b.y + b.h &&
            player.y + player.size > b.y) {
          let overlapX = (player.x + player.size/2 < b.x + b.w/2)
                         ? (player.x + player.size) - b.x
                         : (b.x + b.w) - player.x;
          let overlapY = (player.y + player.size/2 < b.y + b.h/2)
                         ? (player.y + player.size) - b.y
                         : (b.y + b.h) - player.y;
          let overlap = Math.min(overlapX, overlapY);
          if (overlap < mtv.overlap) {
            mtv.overlap = overlap;
            if (overlapX < overlapY) {
              mtv.x = (player.x + player.size/2 < b.x + b.w/2) ? -overlap : overlap;
              mtv.y = 0;
            } else {
              mtv.x = 0;
              mtv.y = (player.y + player.size/2 < b.y + b.h/2) ? -overlap : overlap;
            }
            collisionFound = true;
          }
        }
      }
      if (!collisionFound) break;
      player.x += mtv.x;
      player.y += mtv.y;
      iterations++;
    }
  }

  // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –∏ –ª–æ–≥–∏–∫–∏
  function drawBlocks() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // –†–∏—Å—É–µ–º –∑–≤—ë–∑–¥—ã
    stars.forEach(star => {
      ctx.save();
      ctx.globalAlpha = star.alpha;
      ctx.fillStyle = "white";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "white";
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      star.x += star.dx;
      star.y += star.dy;
      if (star.x < 0) star.x = canvas.width;
      if (star.x > canvas.width) star.x = 0;
      if (star.y < 0) star.y = canvas.height;
      if (star.y > canvas.height) star.y = 0;
    });

    // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É (–µ—Å–ª–∏ –Ω–µ –≤ —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ)
    if (!isPlayMode) {
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath(); 
        ctx.moveTo(x, 0); 
        ctx.lineTo(x, canvas.height); 
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath(); 
        ctx.moveTo(0, y); 
        ctx.lineTo(canvas.width, y); 
        ctx.stroke();
      }
    }

    // –†–∏—Å—É–µ–º –±–ª–æ–∫–∏
    for (const b of blocks) {
      if (b.type === 'shrink' || b.type === 'grow') {
        updateAndDrawParticles(b);
        continue;
      }
      ctx.save();
      if (b.type === 'ban') {
        const pulsate = 20 + 5 * Math.sin(Date.now() / 200);
        ctx.fillStyle = '#aa0000';
        ctx.shadowBlur = pulsate;
        ctx.shadowColor = '#ff3333';
      } else {
        ctx.fillStyle = {
          wall: '#555'
        }[b.type] || '#888';
        ctx.shadowBlur = 0;
      }
      ctx.fillRect(b.x, b.y, b.w, b.h);
      ctx.restore();
    }

    // –†–∏—Å—É–µ–º spawn
    if (spawnPoint) {
      ctx.save();
      ctx.fillStyle = "lime";
      ctx.font = "40px Segoe UI";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("‚óà", spawnPoint.x + gridSize / 2, spawnPoint.y + gridSize / 2);
      ctx.restore();
    }

    // –†–∏—Å—É–µ–º finish
    if (finishPoint) {
      ctx.save();
      ctx.fillStyle = "white";
      ctx.font = "38px Segoe UI";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("‚úî", finishPoint.x + gridSize / 2, finishPoint.y + gridSize / 2);
      ctx.restore();
    }

    // –†–∏—Å—É–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –±–ª–æ–∫–∞ (–ª–µ–≤—ã–π –∫–ª–∏–∫)
    if (isDragging && !isPlayMode && selectedType !== 'spawn' && selectedType !== 'finish') {
      const endX = Math.ceil(currentMouseX / gridSize) * gridSize;
      const endY = Math.ceil(currentMouseY / gridSize) * gridSize;
      const x = Math.min(startX, endX);
      const y = Math.min(startY, endY);
      const w = Math.abs(endX - startX);
      const h = Math.abs(endY - startY);
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.setLineDash([6, 4]);
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);
      ctx.restore();
    }

    // –†–∏—Å—É–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –±–ª–æ–∫–æ–≤ (–ü–ö–ú)
    if (isRightDragging && !isPlayMode) {
      const endX = Math.ceil(currentRightX / gridSize) * gridSize;
      const endY = Math.ceil(currentRightY / gridSize) * gridSize;
      const x = Math.min(startRightX, endX);
      const y = Math.min(startRightY, endY);
      const w = Math.abs(endX - startRightX);
      const h = Math.abs(endY - startRightY);
      ctx.save();
      ctx.strokeStyle = 'rgba(255,0,0,0.8)';
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);
      ctx.restore();
    }

    // –ò–≥—Ä–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ (—Ä–µ–∂–∏–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
    if (isPlayMode) {
      if (!gameEnded) {
        player.vx += player.gravityX;
        player.vy += player.gravityY;
        player.x += player.vx;
        player.y += player.vy;
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –æ–±—ã—á–Ω—ã–º–∏ —Å—Ç–µ–Ω–∞–º–∏ (—Ç–∏–ø "wall")
        let blocked = false;
        for (const b of blocks) {
          if (b.type === 'wall') {
            const collides = player.x < b.x + b.w && (player.x + player.size) > b.x &&
                             player.y < b.y + b.h && (player.y + player.size) > b.y;
            if (collides) {
              blocked = true;
              break;
            }
          }
        }
        if (blocked) {
          player.x -= player.vx;
          player.y -= player.vy;
          player.vx = 0;
          player.vy = 0;
        }
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–æ–Ω –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
        for (const b of blocks) {
          if (b.type === 'shrink' &&
              player.x + player.size > b.x &&
              player.x < b.x + b.w &&
              player.y + player.size > b.y &&
              player.y < b.y + b.h) {
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –º–µ–Ω—å—à–µ, —á—Ç–æ–±—ã –∫—É–±–∏–∫ –ø—Ä–æ—Ö–æ–¥–∏–ª —á–µ—Ä–µ–∑ —É–∑–∫–∏–µ –ø—Ä–æ—Ö–æ–¥—ã
            player.size = Math.floor(gridSize * 0.8);
          } else if (b.type === 'grow' &&
              player.x + player.size > b.x &&
              player.x < b.x + b.w &&
              player.y + player.size > b.y &&
              player.y < b.y + b.h) {
            player.size = gridSize * 2;
          }
        }
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –∑–∞–ø—Ä–µ—â—ë–Ω–Ω—ã–º–∏ –±–ª–æ–∫–∞–º–∏ (ban) ‚Äì –ø–æ—Ä–∞–∂–µ–Ω–∏–µ
        for (const b of blocks) {
          if (b.type === 'ban' &&
              player.x + player.size > b.x &&
              player.x < b.x + b.w &&
              player.y + player.size > b.y &&
              player.y < b.y + b.h) {
            endGame('lose');
            break;
          }
        }
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ñ–∏–Ω–∏—à–∞
        if (finishPoint &&
            player.x + player.size > finishPoint.x &&
            player.x < finishPoint.x + finishPoint.w &&
            player.y + player.size > finishPoint.y &&
            player.y < finishPoint.y + finishPoint.h) {
          endGame('win');
        }
      }
      ctx.save();
      ctx.fillStyle = player.color;
      ctx.shadowBlur = 15;
      ctx.shadowColor = player.color;
      ctx.fillRect(player.x, player.y, player.size, player.size);
      ctx.restore();
    }

    // –ï—Å–ª–∏ –∏–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞, –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    if (gameEnded && endMessage) {
      ctx.save();
      ctx.fillStyle = "white";
      ctx.font = "60px Segoe UI";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(endMessage, canvas.width / 2, canvas.height / 2);
      ctx.restore();
    }

    requestAnimationFrame(drawBlocks);
  }
  drawBlocks();

  // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è –≤ JSON (—á–∞—Å—Ç–∏—Ü—ã –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è)
  document.getElementById('btn-save').addEventListener('click', () => {
    const cleanBlocks = blocks.map(b => {
      if (b.type === 'shrink' || b.type === 'grow') {
        const {particles, ...cleanBlock} = b;
        return cleanBlock;
      }
      return b;
    });
    const data = {
      blocks: cleanBlocks,
      spawn: spawnPoint,
      finish: finishPoint
    };
    const dataStr = JSON.stringify(data, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "level.json";
    a.click();
  });

  // –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Ä–µ–∂–∏–º–∞
  btnPlay.addEventListener('click', () => {
    if (!spawnPoint || !finishPoint) {
      return;
    }
    isPlayMode = true;
    btnPlay.style.display = 'none';
    btnStop.style.display = 'inline-block';
    player.x = spawnPoint.x + gridSize / 2 - player.size / 2;
    player.y = spawnPoint.y + gridSize / 2 - player.size / 2;
    player.vx = 0;
    player.vy = 0;
    player.gravityX = 0;
    player.gravityY = 0.2;
  });

  // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Ä–µ–∂–∏–º–∞
  btnStop.addEventListener('click', stopTestMode);
</script>

</body>
</html>
